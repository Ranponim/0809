# 백엔드-프론트엔드 데이터 구조 양식

이 문서는 3GPP KPI 대시보드 웹사이트의 백엔드(FastAPI)와 프론트엔드(React) 간에 사용되는 주요 데이터 구조 양식을 설명합니다.

## 1. KPI 데이터 (`/api/kpi/statistics`, `/api/kpi/trends`, `POST /api/kpi/query`, `POST /api/kpi/statistics/batch`)

KPI 통계 및 추이 데이터를 전송하는 데 사용되는 기본 데이터 모델입니다.

### `KPIData` 모델
```json
{
  "timestamp": "YYYY-MM-DDTHH:MM:SS",
  "entity_id": "string",
  "kpi_type": "string",
  "value": "float"
}
```
- `timestamp`: 데이터가 기록된 시간 (ISO 8601 형식 문자열).
- `entity_id`: KPI가 측정된 엔티티의 고유 식별자 (예: `LHK078ML1`).
- `kpi_type`: KPI의 종류 (예: `availability`, `rrc`, `erab`, `sar`, `mobility_intra`, `cqi`, `se`, `dl_thp`, `ul_int`).
- `value`: KPI 측정값 (실수).

**예시 응답 (`/api/kpi/statistics` 또는 `/api/kpi/trends`):**
```json
{
  "data": [
    {
      "timestamp": "2025-08-06T00:00:00",
      "entity_id": "LHK078ML1",
      "kpi_type": "availability",
      "value": 99.15
    },
    {
      "timestamp": "2025-08-06T01:00:00",
      "entity_id": "LHK078ML1",
      "kpi_type": "availability",
      "value": 98.92
    }
  ]
}
```

### 배치 통계 (`POST /api/kpi/statistics/batch`)

여러 KPI 타입을 한 번에 조회합니다. 프론트 대시보드에서 대량 KPI 렌더링에 사용됩니다.

요청 바디 예시:
```json
{
  "start_date": "2025-08-06",
  "end_date": "2025-08-07",
  "kpi_types": ["availability", "rrc", "erab"],
  "entity_ids": "LHK078ML1,LHK078MR1",
  "interval_minutes": 60
}
```
응답은 `{"data": { "availability": KPIData[], ... }, "source": "proxy-mock"}` 구조입니다.

### DB 프록시 질의 (`POST /api/kpi/query`)

입력으로 DB 접속 정보와 테이블/컬럼 매핑을 받아 시간(hour) 버킷 평균으로 응답합니다. 실패 시 자동으로 mock 데이터로 폴백합니다.

요청 바디 예시:
```json
{
  "db": {"host":"localhost","port":5432,"user":"postgres","password":"postgres","dbname":"postgres"},
  "table": "summary",
"columns": {"time": "datetime", "peg_name": "peg_name", "value": "value", "ne": "ne", "cellid": "cellid"},
  "start_date": "2025-08-06",
  "end_date": "2025-08-07",
  "kpi_type": "availability",
"kpi_peg_names": ["RRC_Conn_Att","RRC_Conn_Succ"],
"kpi_peg_like": ["Accessibility_%"],
"ne": "nvgnb#10000,nvgnb#20000",
"cellid": "2010,2011"
}
```
응답 형식은 상기 `KPIData` 배열과 동일하며, `{"source": "proxy-db" | "proxy-mock"}` 메타가 포함됩니다.
추가적으로, `interval_minutes`(옵션)를 통해 샘플링 간격(분)을 지정할 수 있습니다.
`kpi_peg_names`(정확 매칭), `kpi_peg_like`(ILIKE 패턴)는 KPI→peg 매핑에 사용합니다(둘 다 없으면 기본집계). 프록시 실패 시 자동으로 mock 데이터(`source: proxy-mock`)를 반환합니다.

## 2. 환경설정 데이터 (`/api/preferences`)

사용자가 대시보드 설정을 저장하고 로드하는 데 사용되는 데이터 모델입니다.

### `PreferenceModel` 모델
```json
{
  "id": "integer" (선택 사항, 생성 시 백엔드에서 할당),
  "name": "string",
  "description": "string" (선택 사항),
  "config": "object" (JSON 객체)
}
```
- `id`: 환경설정의 고유 식별자.
- `name`: 환경설정의 이름.
- `description`: 환경설명에 대한 간략한 설명.
- `config`: 실제 환경설정 내용을 담는 JSON 객체. 이 객체의 구조는 프론트엔드에서 정의하고 백엔드는 이를 그대로 저장하고 반환합니다.

**예시 응답 (`GET /api/preferences`):**
```json
{
  "preferences": [
    {
      "id": 1,
      "name": "My Dashboard Layout",
      "description": "Default layout for KPI dashboard",
      "config": {
        "defaultKPIs": ["availability","rrc"],
        "defaultNEs": ["nvgnb#10000","nvgnb#20000"],
        "defaultCellIDs": ["2010","2011"],
        "availableKPIs": [
          {"value":"availability","label":"Availability (%)","threshold":99.0},
          {"value":"rrc","label":"RRC Success Rate (%)","threshold":98.5}
        ],
        "kpiMappings": {
          "availability": {"peg_like":["Accessibility_%"]},
          "rrc": {"peg_names":["RRC_Conn_Att","RRC_Conn_Succ"]}
        }
      }
    }
  ]
}
```

## 3. 종합 분석 리포트 데이터 (`/api/analysis-result/*`, `/api/reports/summary`)

종합 분석 리포트 내용을 전송하는 데 사용되는 데이터 모델입니다.

### `SummaryReport` 모델 (기본/mock)
```json
{
  "id": "integer",
  "title": "string",
  "content": "string",
  "generated_at": "YYYY-MM-DDTHH:MM:SS"
}
```
- `id`: 리포트의 고유 식별자.
- `title`: 리포트의 제목.
- `content`: 리포트의 본문 내용 (마크다운 형식 문자열).
- `generated_at`: 리포트가 생성된 시간 (ISO 8601 형식 문자열).

**예시 응답 (`GET /api/reports/summary`):**
```json
{
  "reports": [
    {
      "id": 1,
      "title": "주간 네트워크 성능 분석 리포트",
      "content": "# 주간 네트워크 성능 분석 리포트\n\n## 요약\n...",
      "generated_at": "2024-08-13T10:00:00"
    }
  ]
}
```

### 분석 결과 영구 저장 모델 (`/api/analysis-result`)

백엔드는 SQLAlchemy를 통해 분석 결과를 영구 저장합니다(운영: PostgreSQL 권장, 로컬: SQLite 가능). 주요 엔드포인트:

- `POST /api/analysis-result`: 분석 결과 저장
- `GET /api/analysis-result/latest`: 최신 결과 조회
- `GET /api/analysis-result/{id}`: 특정 결과 조회
- `GET /api/analysis-result`: 결과 목록 조회

요청 바디 예시 (`POST /api/analysis-result`):
```json
{
  "status": "success",
  "n_minus_1": "2025-08-06",
  "n": "2025-08-07",
  "analysis": {"executive_summary": "요약 ...", "overall_summary": "..."},
  "stats": [{"kpi":"availability","avg":99.1}],
  "chart_overall_base64": "<base64>",
  "report_path": "/path/to/report.html"
}
```
응답 예시:
```json
{ "id": 12, "created_at": "2025-08-07T09:30:00Z" }
```

## 4. 마스터 데이터 및 파생 PEG (`/api/master/pegs`, `/api/master/cells`, `/api/preferences/{id}/derived-pegs`)

시스템에 등록된 PEG 및 Cell 목록을 제공하는 데 사용되는 데이터 모델입니다.

### PEG 목록 (`/api/master/pegs`)
```json
{
  "pegs": [
    {
      "id": "string",
      "name": "string"
    }
  ]
}
```
- `id`: PEG의 고유 식별자 (예: `PEG001`).
- `name`: PEG의 이름 (예: `Seoul Central`).

### Cell 목록 (`/api/master/cells`)
```json
{
  "cells": [
    {
      "id": "string",
      "name": "string"
    }
  ]
}
```
- `id`: Cell의 고유 식별자 (예: `LHK078ML1`).
- `name`: Cell의 이름 (예: `Seoul-Gangnam-001`).

### 파생 PEG 관리 (`/api/preferences/{id}/derived-pegs`)

사용자 환경설정의 구성(`config`) 안에 파생 PEG 표현식을 저장/조회합니다.

- `GET /api/preferences/{id}/derived-pegs` → `{ "derived_pegs": { "name": "expr" } }`
- `PUT /api/preferences/{id}/derived-pegs` 바디 형식:
```json
{
  "derived_pegs": {
    "PEG_A": "(PEG001 + PEG002) / 2"
  }
}
```
유효하지 않은 형식일 경우 400 오류를 반환합니다.

이러한 데이터 구조는 백엔드와 프론트엔드 간의 통신을 표준화하여 데이터 일관성과 효율적인 개발을 보장합니다.

