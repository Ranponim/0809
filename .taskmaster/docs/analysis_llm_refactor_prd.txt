<context>
# Overview
Analysis LLM MCP 서버의 종합 리펙토링 프로젝트입니다. 현재 코드는 기본적인 기능을 수행하지만, 대용량 데이터 처리, 토큰 관리 최적화, 다중 필터링 성능 향상 등의 측면에서 개선이 필요합니다.

## 현재 시스템의 주요 기능
- PostgreSQL DB 조회 및 집계 (NE/CellID/Host 필터링 지원)
- LLM API를 통한 성능 분석
- HTML 리포트 자동 생성
- Backend API로 분석 결과 전송
- 토큰 계산 및 기본적인 크기 제한

## 리펙토링 목표
- **성능 최적화**: 대용량 데이터 처리 및 토큰 관리 개선
- **안정성 강화**: 예외 처리 및 에러 복구 메커니즘
- **코드 품질**: 모듈화 및 재사용성 향상
- **유지보수성**: 체계적인 로깅 및 테스트 커버리지
- **확장성**: 플러그인 아키텍처 및 설정 기반 확장

## 대상 사용자
- 개발자 (코드 유지보수 및 확장)
- DevOps 엔지니어 (배포 및 모니터링)
- QA 엔지니어 (테스트 및 검증)
- 시스템 관리자 (성능 모니터링)

# Core Features
## 1. 고급 토큰 관리 시스템
- 실시간 토큰 계산 및 모니터링
- 자동 데이터 분할 및 병합 분석
- 메모리 사용량 최적화
- 다양한 토큰 전략 지원

## 2. 최적화된 필터링 엔진
- 다중 NE/CellID/Host 동시 필터링
- 쿼리 최적화 및 인덱스 활용
- 캐싱 메커니즘 적용
- 필터 검증 및 안전성 보장

## 3. 강화된 에러 처리 및 복구
- 단계별 예외 처리
- 자동 재시도 메커니즘
- 부분 실패 시 데이터 보존
- 상세한 에러 로깅 및 추적

## 4. 모듈화된 아키텍처
- 관심사 분리 (DB, LLM, Report, API)
- 플러그인 기반 확장
- 설정 기반 동적 구성
- 의존성 주입 패턴

# User Experience
## 개발자 경험 향상
1. 명확한 모듈 경계 및 인터페이스
2. 종합적인 로깅 시스템
3. 자동화된 테스트 프레임워크
4. 설정 기반 유연한 구성

## 운영 효율성
1. 실시간 성능 모니터링
2. 자동화된 장애 복구
3. 유연한 확장 옵션
4. 체계적인 유지보수 프로세스
</context>

<PRD>
# Technical Architecture
## 현재 아키텍처 분석

### 기존 구조의 문제점
```
analysis_llm.py (1800+ lines)
├── 글로벌 함수 및 상수
├── 유틸리티 함수들
├── DB 연결 및 조회
├── LLM API 호출
├── HTML 리포트 생성
└── Backend API 전송
```

### 목표 아키텍처
```
analysis_llm/
├── core/
│   ├── __init__.py
│   ├── config.py          # 설정 관리
│   ├── logger.py          # 통합 로깅 시스템
│   └── exceptions.py      # 커스텀 예외 클래스
├── db/
│   ├── __init__.py
│   ├── connection.py      # DB 연결 관리
│   ├── query_builder.py   # 쿼리 최적화
│   └── filter_engine.py   # 고급 필터링
├── llm/
│   ├── __init__.py
│   ├── token_manager.py   # 토큰 관리 시스템
│   ├── prompt_builder.py  # 프롬프트 생성
│   ├── api_client.py      # LLM API 클라이언트
│   └── merger.py          # 분할 결과 병합
├── report/
│   ├── __init__.py
│   ├── html_generator.py  # HTML 리포트 생성
│   └── chart_generator.py # 차트 생성
├── api/
│   ├── __init__.py
│   ├── payload_builder.py # Backend payload 구성
│   └── client.py          # Backend API 클라이언트
└── utils/
    ├── __init__.py
    ├── validators.py      # 데이터 검증
    └── performance.py     # 성능 모니터링
```

## 기술 스택 및 도구
### 코어 기술
- **언어**: Python 3.9+
- **비동기 처리**: asyncio, aiohttp
- **데이터 처리**: pandas, numpy
- **설정 관리**: Pydantic Settings
- **로깅**: structlog + JSON 로깅

### 성능 최적화 도구
- **메모리 관리**: psutil, memory_profiler
- **캐싱**: redis (선택적)
- **프로파일링**: cProfile, line_profiler

# Development Roadmap
## Phase 1: 기반 아키텍처 구축 (2주)
### 목표: 모듈화된 기본 구조 완성
- [ ] 프로젝트 구조 재설계 및 모듈 분리
- [ ] 설정 관리 시스템 구현 (Pydantic)
- [ ] 통합 로깅 시스템 구축 (structlog)
- [ ] 커스텀 예외 클래스 정의
- [ ] 기본 단위 테스트 프레임워크 구축

## Phase 2: DB 및 필터링 최적화 (2주)
### 목표: 고성능 데이터 처리
- [ ] DB 연결 풀 및 세션 관리
- [ ] 고급 필터링 엔진 구현
- [ ] 쿼리 최적화 및 인덱스 활용
- [ ] 데이터 검증 및 정제 파이프라인
- [ ] 캐싱 레이어 추가 (선택적)

## Phase 3: LLM 토큰 관리 시스템 (3주)
### 목표: 지능적인 토큰 관리
- [ ] 실시간 토큰 계산 모듈
- [ ] 자동 데이터 분할 전략
- [ ] 분할 분석 결과 병합 로직
- [ ] 메모리 사용량 최적화
- [ ] 다양한 토큰 전략 지원

## Phase 4: 리포트 및 API 최적화 (2주)
### 목표: 안정적인 출력 생성
- [ ] HTML 리포트 생성 최적화
- [ ] Backend payload 구성 개선
- [ ] API 클라이언트 강화
- [ ] 에러 처리 및 재시도 메커니즘

## Phase 5: 통합 및 성능 테스트 (2주)
### 목표: 전체 시스템 검증
- [ ] 통합 테스트 수행
- [ ] 성능 벤치마킹
- [ ] 메모리 누수 검사
- [ ] 로드 테스트 및 안정성 검증

## Phase 6: 배포 및 모니터링 (1주)
### 목표: 운영 환경 준비
- [ ] 배포 스크립트 및 문서화
- [ ] 모니터링 대시보드 구축
- [ ] 롤백 전략 및 장애 대응
- [ ] 유지보수 가이드 작성

# Logical Dependency Chain
## 1단계: 코어 인프라 (Foundation)
### 필수 선행 작업
- [ ] 모듈 구조 설계 및 인터페이스 정의
- [ ] 설정 관리 시스템 구현
- [ ] 로깅 및 모니터링 인프라 구축
- [ ] 기본 예외 처리 프레임워크

### 의존성
- Python 3.9+ 환경
- 기본 라이브러리 (pandas, pydantic, structlog)

## 2단계: 데이터 처리 레이어 (Data Layer)
### 선행 조건: 1단계 완료
- [ ] DB 연결 및 세션 관리
- [ ] 필터링 엔진 구현
- [ ] 데이터 검증 파이프라인
- [ ] 기본 캐싱 메커니즘

### 주요 통합점
- PostgreSQL 스키마 호환성
- NE/CellID 필터링 정확성
- 대용량 데이터 처리 성능

## 3단계: LLM 처리 레이어 (AI Layer)
### 선행 조건: 1단계 + 2단계 완료
- [ ] 토큰 관리 시스템
- [ ] 프롬프트 빌더 개선
- [ ] API 클라이언트 최적화
- [ ] 결과 병합 엔진

### 주요 통합점
- 다양한 LLM 모델 지원
- 토큰 제한 준수
- 분석 품질 유지

## 4단계: 출력 및 통신 레이어 (Output Layer)
### 선행 조건: 1-3단계 완료
- [ ] HTML 리포트 생성기
- [ ] Backend API 클라이언트
- [ ] Payload 빌더 최적화
- [ ] 에러 처리 강화

### 주요 통합점
- Backend API 스키마 호환성
- HTML 리포트 품질
- 네트워크 안정성

## 5단계: 품질 assurance (QA)
### 선행 조건: 1-4단계 완료
- [ ] 단위 테스트 90%+ 커버리지
- [ ] 통합 테스트 시나리오
- [ ] 성능 및 부하 테스트
- [ ] 보안 취약점 검사

## 6단계: 운영 및 유지보수 (Operations)
### 선행 조건: 1-5단계 완료
- [ ] 배포 자동화
- [ ] 모니터링 및 알림 시스템
- [ ] 문서화 및 교육 자료
- [ ] 장애 대응 프로세스

# Risks and Mitigations
## 기술적 리스크

### 1. 토큰 관리 복잡성
**리스크**: 분할 분석 시 결과 품질 저하 가능성
**대응 전략**:
- [ ] 단계별 검증 메커니즘 구현
- [ ] 품질 지표 모니터링
- [ ] A/B 테스트를 통한 최적 전략 선정
- [ ] 전문가 리뷰 프로세스 구축

### 2. 메모리 누수 및 성능 저하
**리스크**: 대용량 데이터 처리 시 메모리 문제
**대응 전략**:
- [ ] 메모리 프로파일링 도구 도입
- [ ] 스트리밍 처리 방식 검토
- [ ] 데이터 청크 처리 구현
- [ ] 정기적인 메모리 모니터링

### 3. DB 쿼리 성능 저하
**리스크**: 복잡한 필터링으로 인한 쿼리 성능 문제
**대응 전략**:
- [ ] 쿼리 최적화 전문가 리뷰
- [ ] 인덱스 전략 수립
- [ ] 쿼리 실행 계획 모니터링
- [ ] 캐싱 레이어 구현

### 4. LLM API 안정성
**리스크**: 외부 API 장애 또는 속도 저하
**대응 전략**:
- [ ] 다중 엔드포인트 페일오버
- [ ] 로컬 LLM 서버 구축 검토
- [ ] API 호출 제한 및 재시도 로직
- [ ] 서킷 브레이커 패턴 구현

## 프로젝트 리스크

### 1. 일정 지연
**리스크**: 각 단계별 복잡성으로 인한 지연
**대응 전략**:
- [ ] 단계별 MVP 정의 및 검증
- [ ] 병렬 개발 가능한 부분 식별
- [ ] 주기적인 진행 상황 리뷰
- [ ] 버퍼 기간 확보

### 2. 기술 부채 축적
**리스크**: 급한 일정으로 인한 코드 품질 저하
**대응 전략**:
- [ ] 코드 리뷰 프로세스 강화
- [ ] 자동화된 품질 게이트
- [ ] 기술 부채 추적 시스템
- [ ] 리팩토링 시간 확보

### 3. 요구사항 변경
**리스크**: 개발 중 요구사항 변경으로 인한 재작업
**대응 전략**:
- [ ] 요구사항 동결 시점 명확화
- [ ] 변경 영향도 평가 프로세스
- [ ] 유연한 아키텍처 설계
- [ ] 버전 관리 전략 수립

# Appendix
## 기술 스택 상세
### 코어 의존성
```
fastapi==0.104.1
pydantic==2.5.0
pydantic-settings==2.1.0
pandas==2.1.4
numpy==1.26.3
psycopg2-binary==2.9.9
sqlalchemy==2.0.23
structlog==23.2.0
memory-profiler==0.61.0
psutil==5.9.7
```

### 개발 및 테스트
```
pytest==7.4.4
pytest-asyncio==0.21.1
pytest-cov==4.1.0
black==23.12.1
isort==5.13.2
mypy==1.8.0
```

## 성능 요구사항
### 응답 시간
- 단일 분석: 30초 이내
- 대용량 데이터: 5분 이내
- 토큰 분할 분석: 각 청크당 45초 이내

### 메모리 사용량
- 기본 분석: 512MB 이내
- 대용량 분석: 2GB 이내
- 메모리 누수: 0 (모니터링)

### 확장성
- 동시 분석 요청: 10개
- 데이터 크기: 최대 1GB
- 토큰 제한: 128K 토큰

## 모니터링 및 로깅
### 로그 레벨 및 포맷
- DEBUG: 상세 디버깅 정보
- INFO: 일반 처리 정보
- WARNING: 경고 상황
- ERROR: 오류 상황
- CRITICAL: 치명적 오류

### 메트릭 수집
- 처리 시간
- 메모리 사용량
- 토큰 사용량
- API 호출 성공률
- DB 쿼리 성능

## 배포 및 운영
### 환경 구성
- 개발 환경: 로컬 Docker
- 스테이징: 클라우드 VM
- 운영: Kubernetes 클러스터

### 모니터링 도구
- Prometheus 메트릭
- Grafana 대시보드
- ELK 스택 로깅
- AlertManager 알림

## 마이그레이션 전략
### 단계적 전환
1. **Phase 1-2**: 신규 모듈 개발 및 병행 운영
2. **Phase 3-4**: 점진적 기능 마이그레이션
3. **Phase 5**: 통합 테스트 및 스위치오버
4. **Phase 6**: 구 버전 제거 및 정리

### 호환성 유지
- API 인터페이스 변경 최소화
- 설정 파일 자동 마이그레이션
- 데이터 포맷 호환성 보장
- 롤백 전략 마련

## 품질 게이트
### 코드 품질
- 단위 테스트 커버리지: 90%+
- 통합 테스트: 필수 시나리오 100%
- 코드 복잡도: 사이클로매틱 10 이하
- 유지보수성 지수: A 등급

### 성능 기준
- P95 응답 시간: 45초 이내
- 메모리 사용률: 80% 이하
- CPU 사용률: 70% 이하
- 에러율: 0.1% 이하

### 보안 요구사항
- 입력 검증: 모든 외부 입력
- SQL 인젝션 방지: 파라미터화 쿼리
- API 키 관리: 환경 변수 또는 Vault
- 로깅 보안: 민감정보 마스킹









