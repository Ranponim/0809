{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "System Architecture & Asynchronous Workflow Setup",
        "description": "Establish the foundational system architecture using React, FastAPI, Celery, and Redis to support long-running, non-blocking analysis tasks.",
        "details": "Implement the architecture described in PRD Section 4.0. This includes setting up the React SPA, a Python FastAPI server for the API, a Celery task queue for processing, and a Redis message broker. Create a basic '/analyze' endpoint that accepts a request, queues a placeholder task in Celery, and allows the frontend to poll for status and results.",
        "testStrategy": "Verify that a request from the frontend successfully creates a Celery task. The frontend should show a loading state and then receive a 'completed' status with mock data from the Redis result backend. Ensure the API server remains responsive while the task is 'running'.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "FastAPI 서버 기본 구조 설정",
            "description": "FastAPI 서버의 기본 구조를 설정하고 필요한 의존성을 설치합니다.",
            "details": "FastAPI 애플리케이션의 기본 구조를 설정하고, 필요한 라이브러리들(Celery, Redis, SQLAlchemy 등)을 requirements.txt에 추가합니다. 기본 라우터 구조와 미들웨어를 설정합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Celery 작업 큐 설정",
            "description": "Celery 작업 큐를 설정하고 Redis를 메시지 브로커로 구성합니다.",
            "details": "Celery 애플리케이션을 설정하고 Redis를 브로커와 결과 백엔드로 구성합니다. 기본 작업 구조와 설정을 정의합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "기본 /analyze 엔드포인트 구현",
            "description": "분석 요청을 받아 Celery 작업을 큐에 추가하는 기본 엔드포인트를 구현합니다.",
            "details": "POST /analyze 엔드포인트를 구현하여 분석 요청을 받고, Celery 작업을 큐에 추가합니다. 작업 ID를 반환하여 프론트엔드에서 상태를 폴링할 수 있도록 합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 4,
            "title": "작업 상태 조회 엔드포인트 구현",
            "description": "작업 상태를 조회할 수 있는 엔드포인트를 구현합니다.",
            "details": "GET /analyze/{task_id}/status 엔드포인트를 구현하여 Celery 작업의 상태를 조회합니다. PENDING, RUNNING, SUCCESS, FAILURE 상태를 반환합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 5,
            "title": "React 프론트엔드 기본 구조 설정",
            "description": "React SPA의 기본 구조를 설정하고 분석 요청 UI를 구현합니다.",
            "details": "React 애플리케이션의 기본 구조를 설정하고, 분석 요청을 위한 폼과 작업 상태를 표시하는 UI를 구현합니다. API 호출과 상태 관리 로직을 추가합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Backend: Implement Automated Test Period Identification",
        "description": "Develop the backend algorithm to automatically identify valid, stable test periods from a user-defined time range.",
        "details": "Implement the 2-step algorithm from PRD Section 3.1.2. Step 1: Use the Python `ruptures` library with the PELT algorithm to perform change point detection on key metrics. Step 2: Filter the resulting segments based on configurable criteria for minimum duration, sustained activity, and statistical stability. The function should return a list of valid start/end timestamps.",
        "testStrategy": "Unit test the algorithm with various time-series datasets, including those with clear test periods, no periods, and noisy data. Verify that the function correctly identifies known valid periods and filters out invalid ones according to the defined criteria.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "ruptures 라이브러리 설치 및 기본 설정",
            "description": "Python ruptures 라이브러리를 설치하고 PELT 알고리즘을 사용하기 위한 기본 설정을 구성합니다.",
            "details": "requirements.txt에 ruptures 라이브러리를 추가하고, change point detection을 위한 기본 설정을 구성합니다. PELT 알고리즘의 기본 파라미터들을 정의합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "PELT 알고리즘을 사용한 Change Point Detection 구현",
            "description": "ruptures 라이브러리의 PELT 알고리즘을 사용하여 시계열 데이터에서 변화점을 감지하는 함수를 구현합니다.",
            "details": "주요 KPI 메트릭들에 대해 PELT 알고리즘을 적용하여 변화점을 감지합니다. 다양한 메트릭(throughput, latency, error rate 등)에 대해 개별적으로 분석하고 결과를 통합합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "세그먼트 필터링 알고리즘 구현",
            "description": "감지된 세그먼트들을 설정 가능한 기준에 따라 필터링하는 알고리즘을 구현합니다.",
            "details": "최소 지속 시간, 지속적인 활동, 통계적 안정성 등의 기준을 적용하여 유효한 테스트 기간을 식별합니다. 설정 가능한 파라미터들을 통해 필터링 기준을 조정할 수 있도록 구현합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "통합 테스트 기간 식별 API 엔드포인트 구현",
            "description": "사용자가 정의한 시간 범위에서 자동으로 유효한 테스트 기간을 식별하는 API 엔드포인트를 구현합니다.",
            "details": "POST /api/analysis/identify-periods 엔드포인트를 구현하여 사용자가 제공한 시간 범위에 대해 자동으로 유효한 테스트 기간을 식별하고 반환합니다. 결과에는 시작/종료 타임스탬프와 신뢰도 점수가 포함됩니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 5,
            "title": "단위 테스트 및 검증 구현",
            "description": "다양한 시계열 데이터셋을 사용하여 알고리즘의 정확성을 검증하는 단위 테스트를 구현합니다.",
            "details": "명확한 테스트 기간이 있는 데이터, 테스트 기간이 없는 데이터, 노이즈가 많은 데이터 등 다양한 시나리오에 대해 테스트를 구현합니다. 알고리즘이 정의된 기준에 따라 올바르게 유효한 기간을 식별하고 유효하지 않은 기간을 필터링하는지 검증합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Backend: Develop Core Statistical Analysis Engine",
        "description": "Build the engine to perform statistical comparisons between two identified test periods ('n' and 'n-1').",
        "details": "As per PRD Section 3.2, for each peg/cell, calculate the key metrics: Average, Delta, Standard Deviation, Relative Standard Deviation (RSD), and Z-Score. Implement the data aggregation logic for summary peg groups. This module will take two dataframes (for n-1 and n periods) as input and output a dataframe with the calculated statistics.",
        "testStrategy": "Create unit tests with pre-calculated expected outputs for a sample dataset. Validate the correctness of each statistical formula. Test edge cases like zero division for RSD calculation or periods with no data.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "통계 분석 엔진 기본 구조 설계",
            "description": "두 테스트 기간('n'과 'n-1') 간의 통계적 비교를 수행하는 엔진의 기본 구조를 설계합니다.",
            "details": "통계 분석 엔진의 핵심 클래스와 인터페이스를 설계합니다. 두 기간의 데이터를 비교하는 기본 메서드들과 통계적 검정을 위한 구조를 정의합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "기본 통계 검정 메서드 구현",
            "description": "t-test, Mann-Whitney U test, Wilcoxon signed-rank test 등 기본적인 통계 검정 메서드들을 구현합니다.",
            "details": "scipy.stats를 사용하여 다양한 통계 검정을 구현합니다. 정규성 검정, 등분산성 검정, 그리고 적절한 검정 방법을 자동으로 선택하는 로직을 포함합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "효과 크기 및 임상적 유의성 계산 구현",
            "description": "Cohen's d, Hedges' g 등 효과 크기 계산과 임상적 유의성 판단 로직을 구현합니다.",
            "details": "통계적 유의성뿐만 아니라 실제적인 의미가 있는 차이인지를 판단하기 위한 효과 크기 계산과 임상적 유의성 기준을 구현합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 4,
            "title": "통합 분석 결과 생성 및 보고서 생성",
            "description": "모든 통계 분석 결과를 통합하여 종합적인 분석 보고서를 생성하는 기능을 구현합니다.",
            "details": "각 메트릭별 통계 검정 결과, 효과 크기, 임상적 유의성을 종합하여 Pass/Fail 판단을 위한 종합 보고서를 생성합니다. JSON 형태의 구조화된 결과와 사람이 읽기 쉬운 텍스트 보고서를 모두 제공합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 5,
            "title": "통계 분석 API 엔드포인트 구현",
            "description": "통계 분석을 수행하는 API 엔드포인트를 구현하여 프론트엔드에서 호출할 수 있도록 합니다.",
            "details": "POST /api/analysis/statistical-comparison 엔드포인트를 구현하여 두 테스트 기간의 데이터를 받아 통계 분석을 수행하고 결과를 반환합니다. 분석 요청, 진행 상황 조회, 결과 조회 기능을 포함합니다.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Frontend: Build Analysis Setup and Period Selection UI",
        "description": "Create the user interface for initiating an analysis, including date range selection and manual override for test periods.",
        "details": "Based on PRD Section 3.1.1, implement a React component with a date/time range picker and an 'Analyze' button. After the backend identifies test periods (from Task 2), populate two dropdown menus ('Baseline Period (n-1)' and 'Comparison Period (n)') with the results, defaulting to the two most recent periods. Allow the user to manually select any two periods from the dropdowns to re-run the analysis.",
        "testStrategy": "UI testing: Verify the date picker works correctly. After clicking 'Analyze', confirm the loading indicator appears and the dropdowns are populated with data from a mock API response. Test the manual selection and re-analysis trigger.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Backend: Implement ML Feature Engineering and LSTM Autoencoder",
        "description": "Develop the initial machine learning model for anomaly detection using an LSTM Autoencoder.",
        "details": "Implement the feature engineering pipeline described in PRD Section 3.3.1 to convert raw Multi-UE data into a structured multivariate time series (mean, std, skew, etc.). Build and pre-train a stacked LSTM Autoencoder model (using PyTorch or TensorFlow) on a 'golden' dataset as per PRD Section 3.3.2. The model should take a time-series window as input and output a reconstruction error, which serves as the anomaly score.",
        "testStrategy": "Validate the feature engineering output for a sample input. Train the model and verify that the reconstruction error is low for normal data and significantly higher for known anomalous data. Save the trained model for inference.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Backend: Implement Pass/Fail Logic and Integrate Full Analysis Workflow",
        "description": "Create the final Pass/Fail determination engine and integrate all backend modules into a single, cohesive Celery task.",
        "details": "Develop the configurable rules engine from PRD Section 3.4.1, which flags a peg/cell as 'Fail' based on Z-Score, RSD, and anomaly score thresholds. Update the Celery task to orchestrate the full workflow: 1) Identify periods (Task 2), 2) Run statistical analysis (Task 3), 3) Run anomaly detection (Task 5), 4) Apply Pass/Fail logic. The final output should be a structured JSON object containing all results for the frontend.",
        "testStrategy": "Create integration tests for the Celery task. Provide input data and verify that the final JSON output is correctly structured and that the Pass/Fail logic is applied correctly based on the intermediate results and configured thresholds.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Authentication Database Schema",
            "description": "Create the necessary database tables and relationships to store user credentials, profiles, roles, and session information securely.",
            "dependencies": [],
            "details": "Define a `users` table with columns for `id`, `username`, `email`, `password_hash`, `created_at`, and `updated_at`. Create a `password_resets` table to store temporary tokens. Use a database migration tool to script and apply the schema changes.",
            "status": "done",
            "testStrategy": "Run migrations on a test database and verify that all tables, columns, and constraints are created as expected. Write a test script to perform basic CRUD operations on the `users` table to ensure it functions correctly."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., `POST /api/auth/register`) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept `username`, `email`, and `password`. Implement input validation for email format, password strength, and username uniqueness. Use a strong hashing algorithm like bcrypt to hash the password before storing it. Return a success message or user object upon successful registration.",
            "status": "done",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate email/username, registration with a weak password, and registration with invalid input data. Assert correct HTTP status codes and database state for each case."
          },
          {
            "id": 3,
            "title": "Develop User Login API Endpoint and JWT Generation",
            "description": "Create an endpoint (e.g., `POST /api/auth/login`) for users to authenticate and receive a JSON Web Token (JWT) for session management.",
            "dependencies": [],
            "details": "The endpoint should accept `email` and `password`. It must retrieve the user from the database and securely compare the provided password with the stored hash. If credentials are valid, generate a signed JWT containing user claims (e.g., user ID, roles) with a set expiration time. Implement rate limiting to prevent brute-force attacks.",
            "status": "done",
            "testStrategy": "Write integration tests for successful login (assert a valid JWT is returned), login with incorrect credentials (assert 401 Unauthorized), and login for a non-existent user. Unit test the JWT generation and signing logic separately."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create a middleware that intercepts requests to protected API endpoints, validates the user's JWT, and grants or denies access accordingly.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. It must verify the token's signature and expiration. If valid, decode the payload and attach the user's identity to the request context. If invalid, it must return a 401 Unauthorized or 403 Forbidden response.",
            "status": "done",
            "testStrategy": "Create a test-only protected endpoint. Write integration tests that attempt to access this endpoint with a valid token, an expired token, an invalid/malformed token, and no token. Assert the correct HTTP response for each scenario."
          },
          {
            "id": 5,
            "title": "Implement Secure Password Reset Flow",
            "description": "Develop the API endpoints and logic to allow users to securely reset a forgotten password via an email link.",
            "dependencies": [],
            "details": "Create a `POST /api/auth/forgot-password` endpoint that takes an email, generates a unique, single-use, time-limited token, and sends a reset link to the user's email. Create a `POST /api/auth/reset-password` endpoint that accepts the token and a new password, validates the token, and updates the user's password hash.",
            "status": "done",
            "testStrategy": "Unit test the token generation and validation logic. Write an end-to-end integration test that calls the 'forgot-password' endpoint, captures the token (mocking the email service), and then uses that token to successfully call the 'reset-password' endpoint. Test failure cases like using an expired or invalid token."
          }
        ]
      },
      {
        "id": 7,
        "title": "Frontend: Build Main Dashboard with Summary and Results Table",
        "description": "Develop the main results dashboard to display the analysis summary and a detailed table of all pegs/cells.",
        "details": "Following PRD Section 3.4.2, create the main UI view. At the top, display the summary cards: Overall Status, Failed Pegs, Failed Cells, and Analysis Periods. Below, implement a feature-rich table (e.g., using MUI X DataGrid) to display the results for all pegs/cells. The table must support pagination, sorting by any column (e.g., Z-Score), and filtering (e.g., to show only 'Fail' items).",
        "testStrategy": "Develop the component using mock data that mirrors the final API response from Task 6. Verify that all summary cards display the correct aggregated data. Test all table functionalities: pagination, sorting (ascending/descending), and filtering.",
        "priority": "high",
        "dependencies": [
          4,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database tables and migrations to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for id, username, email, password_hash, created_at, and updated_at. Use a migration tool like Alembic or Flyway to manage schema versions.",
            "status": "done",
            "testStrategy": "Run the migration script and verify the table structure and constraints directly in the database. Write a unit test to ensure the migration runs without errors."
          },
          {
            "id": 2,
            "title": "Implement User Registration Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept username, email, and password. It must validate input, hash the password using bcrypt, and store the new user in the database. Return a 201 status on success.",
            "status": "done",
            "testStrategy": "Write integration tests for successful registration, registration with a duplicate email/username, and registration with invalid data (e.g., weak password, invalid email format)."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an endpoint (e.g., POST /api/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should verify the provided credentials against the stored password hash. Upon success, generate a signed JWT containing the user ID and an expiration claim.",
            "status": "done",
            "testStrategy": "Test the endpoint with valid credentials (expect a JWT), invalid credentials (expect a 401 Unauthorized error), and for non-existent users."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to verify the JWT on incoming requests to secure endpoints.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header, validate its signature and expiration, and attach the user's identity to the request context if valid. If invalid, it should return a 401 or 403 error.",
            "status": "done",
            "testStrategy": "Create a test-only protected endpoint. Write tests that call it with a valid token, an expired token, a malformed token, and no token, verifying the correct HTTP response for each case."
          },
          {
            "id": 5,
            "title": "Implement Protected User Profile Endpoint",
            "description": "Create a protected endpoint (e.g., GET /api/users/me) that returns the profile information for the authenticated user.",
            "dependencies": [],
            "details": "This endpoint must use the authentication middleware. It will use the user ID from the request context (populated by the middleware) to fetch the user's data from the database, omitting sensitive fields like the password hash.",
            "status": "done",
            "testStrategy": "Write an integration test that first logs in to obtain a JWT, then uses that token to successfully call this endpoint and verify the returned user data is correct and does not contain the password hash."
          }
        ]
      },
      {
        "id": 8,
        "title": "Frontend: Create Detailed View with Time-Series Chart and Anomaly Highlighting",
        "description": "Build the drill-down view that provides detailed diagnostics for a selected peg or cell, including an interactive time-series chart.",
        "details": "As specified in PRD Section 3.4.3, when a user clicks a row in the main table (Task 7), navigate to a detailed view. This view should contain a simple metrics table and a time-series comparison chart (e.g., using MUI X Charts). The chart must plot the 'n-1' period (gray line) overlaid with the 'n' period (blue line). Crucially, highlight the points in the 'n' period where anomalies were detected (from the ML model) using red dots or a shaded region.",
        "testStrategy": "Using mock data, verify that clicking a table row navigates to the correct detail page. Ensure the chart renders both time-series correctly and that the anomaly highlighting is accurately displayed based on the input data.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Authentication Database Schema",
            "description": "Define the database tables, columns, and relationships required for storing user data, including credentials, profile information, and session tokens.",
            "dependencies": [],
            "details": "Create an ERD for `users`, `user_profiles`, and `sessions` tables. The `users` table must include `id`, `email`, `password_hash`, `created_at`, and `updated_at`. Ensure `email` is unique. The `password_hash` field should be of sufficient length for bcrypt or Argon2 hashes.",
            "status": "done",
            "testStrategy": "Peer review the schema design for completeness, normalization, and performance considerations. Validate data types and constraints. Ensure indexes are planned for frequently queried columns like `email`."
          },
          {
            "id": 2,
            "title": "Develop Backend API Endpoints for Registration and Login",
            "description": "Create the server-side API endpoints for user registration (`POST /api/auth/register`) and login (`POST /api/auth/login`).",
            "dependencies": [],
            "details": "The registration endpoint will validate input, check for existing users, hash the password, and create a new user record. The login endpoint will authenticate credentials, and upon success, generate and return a JSON Web Token (JWT).",
            "status": "done",
            "testStrategy": "Use an API testing tool like Postman. Test successful registration, registration with a duplicate email, login with valid credentials, and login with invalid credentials. Verify that a valid JWT is returned on successful login."
          },
          {
            "id": 3,
            "title": "Implement Secure Password Hashing and Storage",
            "description": "Integrate a robust, one-way hashing algorithm for user passwords to ensure they are never stored in plaintext.",
            "dependencies": [],
            "details": "Use the bcrypt or Argon2 library to hash passwords during registration and to compare hashes during login. The salt should be automatically generated and stored as part of the hash string. Implement strict input validation on all endpoints.",
            "status": "done",
            "testStrategy": "Write unit tests for the password hashing and verification functions. Manually inspect the database to confirm that stored passwords are fully hashed and not in plaintext. Perform a code review focused on security."
          },
          {
            "id": 4,
            "title": "Build Frontend UI for Login and Registration Pages",
            "description": "Create the user interface components for the login and registration forms using the project's designated frontend framework.",
            "dependencies": [],
            "details": "Develop responsive and accessible forms with fields for email and password. Implement client-side validation to provide immediate feedback to the user (e.g., email format, password complexity requirements).",
            "status": "done",
            "testStrategy": "Perform cross-browser and multi-device testing to ensure responsive design works as expected. Write component tests to verify form validation logic and state management. Conduct an accessibility check (WCAG)."
          },
          {
            "id": 5,
            "title": "Integrate Frontend Forms with Backend Authentication API",
            "description": "Connect the frontend UI components to the backend registration and login endpoints to enable user interaction.",
            "dependencies": [],
            "details": "Use a library like Axios or the native Fetch API to handle HTTP requests. On successful login, store the received JWT securely in the client (e.g., HttpOnly cookie or local storage). Implement user feedback for success and error states.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing by creating a new user via the registration form and then logging in with those credentials. Use browser developer tools to monitor network requests and verify the JWT is received and stored correctly."
          },
          {
            "id": 6,
            "title": "Implement Protected Routes and Session Management",
            "description": "Create a mechanism to restrict access to certain parts of the application to authenticated users only.",
            "dependencies": [],
            "details": "On the frontend, create a route guard or higher-order component that checks for a valid JWT before rendering a protected component. If the token is invalid or missing, redirect to the login page. On the backend, create middleware to validate the JWT on all protected API endpoints.",
            "status": "done",
            "testStrategy": "Test that attempting to access a protected route without logging in redirects to the login page. After logging in, confirm that protected routes are accessible. Test the logout functionality to ensure the token is cleared and access is revoked."
          },
          {
            "id": 7,
            "title": "Develop Password Reset Functionality",
            "description": "Implement a secure 'Forgot Password' workflow that allows users to reset their password via an email link.",
            "dependencies": [],
            "details": "Create an endpoint to generate a unique, single-use, time-limited reset token and email a reset link to the user. Create a new frontend page for the user to enter a new password. Create a final endpoint to validate the token and update the user's password hash in the database.",
            "status": "done",
            "testStrategy": "End-to-end test the entire flow: request a reset, use a mail-trapping service to verify the email and click the link, set a new password, and log in with the new credentials. Test with invalid or expired tokens to ensure they are rejected."
          }
        ]
      },
      {
        "id": 9,
        "title": "Backend: Implement Transformer Model and Ensemble Anomaly Scoring",
        "description": "Enhance the anomaly detection capability by adding a Transformer-based model and creating an ensemble score.",
        "details": "Implement the Transformer-based autoencoder model as described in PRD Section 3.3.3 to capture long-range dependencies in the time-series data. Develop the ensemble scoring mechanism (PRD 3.3.4) that normalizes the anomaly scores from both the LSTM (Task 5) and Transformer models and combines them into a single, more robust score using a weighted average. Update the main analysis workflow (Task 6) to use this new ensemble score.",
        "testStrategy": "Compare the Transformer model's performance against the LSTM on a benchmark dataset. Test the ensemble function to ensure scores are normalized and combined correctly. Verify that the main workflow now outputs the ensemble score.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the database table(s) to store user information, including username, hashed password, email, and timestamps.",
            "dependencies": [],
            "details": "Use a migration tool (e.g., Alembic, Flyway) to create a 'users' table. Fields should include 'id' (primary key), 'username' (unique, indexed), 'email' (unique, indexed), 'hashed_password' (string), 'created_at', and 'updated_at'. Ensure proper constraints are set.",
            "status": "done",
            "testStrategy": "Verify the migration runs successfully up and down. Manually inspect the database schema to confirm all fields, types, and constraints are correct. Write a unit test to create and retrieve a dummy user record using the data model."
          },
          {
            "id": 2,
            "title": "Create User Registration API Endpoint",
            "description": "Develop a public API endpoint (e.g., POST /api/users/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept a username, email, and password. It must validate the input (e.g., password strength, valid email format), check for existing username/email, hash the password using a strong algorithm (like bcrypt), and save the new user to the database. Return a success message or appropriate error codes.",
            "status": "done",
            "testStrategy": "Write integration tests to cover: successful registration, registration with a duplicate username, registration with a duplicate email, registration with an invalid email format, and registration with a weak password. Test for correct HTTP status codes (201, 400, 409)."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should accept a username/email and password. It will find the user in the database, compare the provided password with the stored hash, and if they match, generate a signed JWT. The JWT payload should include user ID and an expiration time. The token should be returned in the response body.",
            "status": "done",
            "testStrategy": "Write integration tests for: successful login with correct credentials, failed login with incorrect password, and failed login with a non-existent username. Verify the structure and signature of the returned JWT. Test that the token payload contains the correct user ID and an expiration claim."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Token Verification",
            "description": "Develop middleware to protect specific API routes by verifying the JWT from the Authorization header.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header. It must validate the token's signature and check its expiration. If valid, it should decode the payload, identify the user, and attach the user object to the request context. If invalid, it should return a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Unit test the middleware logic directly. Write integration tests for a protected endpoint: test access with a valid token, access with an expired token, access with an invalid/tampered token, and access with no token. Ensure correct HTTP status codes (200 for success, 401 for failures)."
          },
          {
            "id": 5,
            "title": "Implement Protected 'Get User Profile' Endpoint",
            "description": "Create a protected API endpoint (e.g., GET /api/users/me) that returns the profile information of the currently authenticated user.",
            "dependencies": [],
            "details": "Apply the authentication middleware to this route. The route handler should use the user information attached to the request by the middleware to fetch the user's details (excluding the password hash) from the database and return them as a JSON response.",
            "status": "done",
            "testStrategy": "Use integration tests. First, obtain a valid JWT by calling the login endpoint. Then, use that token to make a request to the /api/users/me endpoint and verify that the correct user data is returned and that the hashed password is not included. Also, test that accessing this endpoint without a valid token results in a 401 error."
          }
        ]
      },
      {
        "id": 10,
        "title": "System: End-to-End Integration, Testing, and Deployment",
        "description": "Integrate all frontend and backend components, perform comprehensive end-to-end testing, and prepare the feature for deployment.",
        "details": "Connect the live frontend components to the final backend API endpoints. Test the entire user journey: selecting a time range, running the analysis, viewing the summary dashboard, and drilling down into the detailed diagnostic view. Conduct performance testing to ensure the analysis completes within an acceptable timeframe. Document the final configuration and deployment process.",
        "testStrategy": "Execute a full user acceptance test (UAT) scenario with real-world log data. Verify data consistency between the backend calculations and frontend visualizations. Confirm the asynchronous workflow is seamless and provides appropriate feedback to the user. Check for and resolve any integration bugs.",
        "priority": "high",
        "dependencies": [
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including username, hashed password, email, and timestamps.",
            "dependencies": [],
            "details": "Use a migration tool to create a 'users' table. Columns should include 'id' (primary key), 'username' (unique, indexed), 'email' (unique, indexed), 'hashed_password' (string), 'created_at', and 'updated_at'. Ensure password hashes are stored, never plain text.",
            "status": "done",
            "testStrategy": "Write a unit test for the database migration to ensure the table and columns are created correctly. Verify constraints like 'unique' and 'not null' are applied."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Implement a public API endpoint (e.g., POST /api/users/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept a username, email, and password. It must validate the input (e.g., password complexity, valid email format), check for existing username/email, hash the password using bcrypt, and save the new user record to the database.",
            "status": "done",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate username/email, and registration with an invalid password or email. Ensure the stored password is a hash."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint and JWT Generation",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive an access token.",
            "dependencies": [],
            "details": "The endpoint should accept a username/email and a password. It will retrieve the user from the database, compare the provided password with the stored hash, and if they match, generate a JSON Web Token (JWT). The JWT should contain user identifiers (like user ID) and have an expiration time.",
            "status": "done",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. Verify the structure and claims of the generated JWT."
          },
          {
            "id": 4,
            "title": "Develop Authentication Middleware for Protected Routes",
            "description": "Create a middleware or decorator that can be applied to API endpoints to ensure only authenticated users can access them.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the request's 'Authorization' header. It must then validate the token's signature and expiration. If valid, it should decode the payload to identify the user and attach the user object or ID to the request context.",
            "status": "done",
            "testStrategy": "Test the middleware by making requests to a protected endpoint with a valid token, an invalid/tampered token, an expired token, and no token at all. Assert that the correct HTTP status codes (e.g., 200, 401, 403) are returned."
          },
          {
            "id": 5,
            "title": "Create a Protected 'Get Current User' Endpoint",
            "description": "Implement a protected API endpoint (e.g., GET /api/users/me) that returns the details of the currently authenticated user.",
            "dependencies": [],
            "details": "This endpoint will be protected by the authentication middleware. It will use the user information from the request context to fetch the user profile from the database (excluding sensitive data like the password hash) and return it as a JSON response.",
            "status": "done",
            "testStrategy": "Write an end-to-end test. The test should first call the login endpoint to get a valid JWT, then use that JWT in the 'Authorization' header to call the '/api/users/me' endpoint and verify that the correct user data is returned."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-24T12:53:23.389Z",
      "updated": "2025-08-24T18:07:56.887Z",
      "description": "Tasks for master context"
    }
  }
}